<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>0xRevSec - Software Projects & Reverse Engineering</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
<div id="nav-placeholder"></div>
    <main>
    <article class="article">
      <h1>Projet Modbus RTU entre deux ESP32 (UART‚ÄëTTL direct)</h1>

      <h2>1. Contexte &amp; Objectif</h2>
      <p>
        Dans l‚Äôautomatisation industrielle, Modbus est un protocole populaire pour √©changer des donn√©es entre un ma√Ætre et plusieurs esclaves via une ligne s√©rie.
        Ici, nous montrons comment r√©aliser un √©change Modbus RTU <strong>sans module RS‚Äë485</strong>, en liaison directe UART‚ÄëTTL entre deux ESP32, pour lire la temp√©rature d‚Äôune sonde et piloter un moteur DC. La commande utilisateur se fera depuis un PC sur interface
        graphique (supervision). Le esp32 maitre aura un mini serveur HTTP et pourra communiquer avec la supervision en WIFI.
        <br>Ce projet a pour but de comprendre en bas niveau ce que nous comprenons en surface.
      </p>
      <ul>
        <li><strong>Commande par supervision PC</strong> : envoi de requ√™tes HTTP au serveur h√©berg√© sur l‚ÄôESP32 ma√Ætre.</li>
        <li><strong>ESP32 ma√Ætre</strong> interroge l‚Äôesclave et affiche la valeur ou demande de pilotage le moteur (requ√™te Modbus).</li>
        <li><strong>ESP32 esclave</strong> lit la temp√©rature, active le moteur et r√©pond aux requ√™tes (requ√™te Modbus).</li>
        <li><strong>Communication point‚Äë√†‚Äëpoint, full‚Äëduplex, via TX/RX crois√©s.</li>
        <li>Analyse des paquets HTTP et requ√™te modbus.</li>
        <li>Ajout convertisseur RS485 et test robustesse.</li>
      </ul>
      <img src="image/synoptique_modbuspng.png" alt="Sch√©ma de c√¢blage Modbus" style="max-width: 85%">

      

      <h2>2. Mat√©riel N√©cessaire</h2>
      <h3>2.1. Liste des composants</h3>
      <p>Pour r√©aliser ce projet, vous aurez besoin de :</p>
      <ul>
        <li>2 √ó cartes <strong>ESP32</strong> (DevKitC ou √©quivalent).</li>
        <li>1 √ó sonde de temp√©rature (par exemple, un thermistor NTC).</li>
        <li>1 √ó r√©sistance 2K (pour le thermistor).</li>
        <li>1 √ó moteur DC + 1 module de pilotage <strong>L298N</strong>.</li>
        <li>C√¢bles Dupont m√¢le-m√¢le pour les connexions.</li>
        <li>Une alimentation 5 V (avec un r√©gulateur 3.3 V si votre ESP32 le n√©cessite).</li>
        <li>Un PC avec l'application Python de supervision.</li>
        <li>Un <strong>analyseur logique</strong> (optionnel mais fortement recommand√© pour le d√©bogage).</li>
      </ul>

      <h3>2.2. C√¢blage</h3>
      <p>Voici les connexions essentielles :</p>
      <p><strong>Liaison UART-TTL (entre les GPIO 16/17 du ma√Ætre et de l'esclave) :</strong></p>
      <ul>
        <li>Ma√Ætre <strong>TX</strong> (GPIO 17) ‚Üí Esclave <strong>RX</strong> (GPIO 16)</li>
        <li>Ma√Ætre <strong>RX</strong> (GPIO 16) ‚Üê Esclave <strong>TX</strong> (GPIO 17)</li>
        <li><strong>GND commun</strong> entre les deux ESP32.</li>
      </ul>
      <p><strong>Sonde de Temp√©rature (sur l'ESP32 Esclave) :</strong></p>
      <ul>
        <li><strong>3.3V</strong> de l'ESP32 ‚Üí Une borne du thermistor.</li>
        <li>L'autre borne du thermistor ‚Üí Une borne de la r√©sistance 2K.</li>
        <li>L'autre borne de la r√©sistance 2K ‚Üí <strong>GND</strong> de l'ESP32.</li>
        <li><strong>GPIO 34 (ADC)</strong> de l'esclave sur la jonction entre le thermistor et la r√©sistance 2K.</li>
      </ul>
      <p><strong>Moteur (sur l'ESP32 Esclave) :</strong></p>
      <ul>
        <li>Module <strong>L298N</strong> :
          <ul>
            <li>Alimenter le L298N en <strong>5V</strong> (bornes +/-).</li>
            <li>Relier IN1 du L298N au <strong>GPIO 12</strong> de l'esclave.</li>
            <li>Relier IN2 du L298N au <strong>GPIO 13</strong> de l'esclave.</li>
            <li>Connecter les bornes MotorA/MotorB du L298N au moteur DC.</li>
          </ul>
        </li>
      </ul>
      <br>
       <img src="image/cablage.jpg" alt="Sch√©ma de c√¢blage Modbus" style="max-width: 85%; height: auto; display: block;">
        <p><em>Cablage sur plaquette</em>

        <img src="image/cablage_reel.png" alt="Sch√©ma de c√¢blage Modbus" style="max-width: 85%; height: auto; display: block;">
         <p><em>Schema de cablage</em>


     
      <h2>3. Th√©orie du Protocole Modbus et Couches de Communication</h2>
      <p>Dans l'automatisation industrielle, la communication est vitale. Le protocole Modbus, reconnu pour sa robustesse, est omnipr√©sent. Pour comprendre son fonctionnement et son adaptation aux divers environnements, le <strong>Mod√®le OSI (Open Systems Interconnection)</strong> est un cadre indispensable.</p>

      <h3>3.1. Le Mod√®le OSI : Une Vue d'Ensemble</h3>
      <p>Le mod√®le OSI d√©compose la communication en sept couches abstraites, chacune ayant une fonction sp√©cifique :</p>
      <ul>
        <li><strong>Couche 7 (Application) :</strong> La plus proche de l'utilisateur final. Elle d√©finit le "quoi" et le "comment" de la communication (ex: lire une temp√©rature). C'est l√† que r√©sident <strong>Modbus RTU</strong> et <strong>Modbus TCP/IP</strong>.</li>
        <li><strong>Couche 4 (Transport) & Couche 3 (R√©seau) :</strong> Pertinentes pour Modbus TCP/IP (protocoles TCP et IP).</li>
        <li><strong>Couche 1 (Physique) :</strong> D√©crit les sp√©cifications √©lectriques et m√©caniques de la transmission des bits bruts. On y trouve <strong>UART-TTL, RS-232, RS-485, et Ethernet</strong>.</li>
      </ul>

      <h3>3.2. Le Protocole Modbus RTU : Le "Langage" Applicatif (Couche 7)</h3>
      <p><strong>Modbus RTU</strong> (Remote Terminal Unit) est un protocole de la <strong>couche application (OSI 7)</strong>. Il d√©finit le format des messages (adresse esclave, code de fonction, donn√©es, CRC) permettant aux appareils de dialoguer selon un mod√®le <strong>ma√Ætre/esclave</strong>. Sa force majeure est son <strong>ind√©pendance vis-√†-vis de la couche physique</strong> : les messages Modbus RTU restent identiques, quel que soit le support de transmission sous-jacent.</p>

      <h3>3.3. La Couche Physique dans Notre Projet : UART-TTL (Couche 1)</h3>
      <p>Dans notre projet p√©dagogique, nous utilisons l'<strong>UART-TTL (OSI 1)</strong> comme couche physique. L'UART est un module s√©rie int√©gr√© aux microcontr√¥leurs, g√©rant la conversion parall√®le-s√©rie. TTL fait r√©f√©rence aux niveaux de tension (0V/3.3V ou 5V). La connexion est directe avec 3 fils (TX, RX, GND). La configuration "<strong>9600 bauds 8N1</strong>" est logicielle et d√©finit la vitesse (9600 bits/s), 8 bits de donn√©es, pas de parit√©, et 1 bit de stop. Cependant, le TTL est tr√®s sensible au bruit et limit√© √† quelques m√®tres.</p>

      <h3>3.4. Le Standard Industriel : RS-485 (Couche 1 - Robustesse)</h3>
      <p>Pour l'industrie, le <strong>RS-485 (OSI 1)</strong> est le standard gr√¢ce √† sa <strong>robustesse</strong> :</p>
      <ul>
        <li><strong>Longue Distance :</strong> Jusqu'√† 1200 m√®tres.</li>
        <li><strong>Immunit√© au Bruit :</strong> Utilise la <strong>transmission diff√©rentielle</strong> (diff√©rence de tension entre deux fils A et B), annulant les interf√©rences.</li>
        <li><strong>Multi-points :</strong> Un seul bus peut connecter de nombreux appareils (souvent 32+ sans r√©p√©teur).</li>
        <li><strong>Migration :</strong> Pour passer de l'UART-TTL au RS-485, un <strong>module convertisseur RS-485</strong> (ex: MAX485) est n√©cessaire. Il adapte les niveaux de tension sans modifier la logique Modbus RTU de l'ESP32.</li>
      </ul>

      <h3>3.5. Autres Couches Physiques et Variantes de Modbus</h3>
      <p>Le protocole Modbus est flexible et peut √™tre adapt√© √† d'autres supports ou variantes :</p>
      <ul>
        <li><strong>RS-232 (OSI 1) :</strong> Interface s√©rie plus ancienne, point-√†-point (max ~15m), sensible au bruit.</li>
        <li><strong>Fibre Optique (OSI 1) :</strong> Transmission par lumi√®re. N√©cessite des convertisseurs s√©rie-vers-fibre. Offre des distances extr√™mes (km) et une immunit√© totale aux interf√©rences et √† l'isolation √©lectrique.</li>
        <li><strong>Sans Fil (OSI 1) :</strong> Via des passerelles radio (Wi-Fi, LoRa, 4G/5G) qui encapsulent les trames Modbus RTU. Propose une installation flexible, mais peut introduire latence et d√©fis de fiabilit√©/s√©curit√©.</li>
        <li><strong>Modbus TCP/IP sur Ethernet (OSI 1-7) :</strong> Une variante distincte de Modbus. Elle encapsule les messages Modbus directement dans TCP/IP (OSI 3/4) et utilise <strong>Ethernet (OSI 1)</strong>. Offre un haut d√©bit, s'int√®gre aux r√©seaux IT et permet un acc√®s distant. C'est la norme pour les grandes installations connect√©es.</li>
      </ul>

      <h3>3.6. D√©tails de la Trame UART S√©rie</h3>
      <p>Pour une communication UART Modbus RTU, chaque octet est encod√© avec :</p>
      <ul>
        <li><strong>1 bit de start (0) :</strong> Indique le d√©but de la transmission d'un caract√®re.</li>
        <li><strong>8 bits de donn√©es :</strong> Les octets Modbus eux-m√™mes.</li>
        <li><strong>1 bit de stop (1) :</strong> Indique la fin du caract√®re.</li>
        <li><strong>D√©lai inter-trame (3.5T) :</strong> Un silence d'au moins 3,5 caract√®res de temps (`3.5 * (10 bits / baud rate)`) marque la fin d'une trame Modbus compl√®te et le d√©but potentiel d'une nouvelle.</li>
        <li><strong>Calcul du CRC Modbus :</strong> Le <strong>CRC-16 Modbus</strong> est une somme de contr√¥le ajout√©e √† la fin de chaque trame pour garantir son int√©grit√©. Si le CRC re√ßu ne correspond pas au CRC calcul√© par le r√©cepteur, la trame est consid√©r√©e comme corrompue et ignor√©e.</li>
      </ul>
<br>
 <img src="image/graph.png" alt="Sch√©ma de c√¢blage Modbus" style="max-width: 85%; height: auto; display: block;">
 <br>
  

      <h2>4. Impl√©mentation ESP32 : Le Code (Lien code : <a href="https://github.com/0xRevSec/Modbus_RTU.git">github.com</a>)</h2>
      <p>Cette section d√©crit la structure du code et son fonctionnement sur les deux ESP32, ma√Ætre et esclave.</p>

      <h3>4.1. Structure des Fichiers du Projet</h3>
      <p>Pour une organisation claire, notre projet est structur√© en plusieurs fichiers :</p>
      <ul>
        <li><strong>Dossier <code>include/</code> :</strong> Contient les d√©finitions et fonctions r√©utilisables.
          <ul>
            <li><code>modbus_master.h</code> : Fonctions Modbus pour l'ESP32 ma√Ætre (client).</li>
            <li><code>modbus_slave.h</code> : Fonctions Modbus pour l'ESP32 esclave (serveur).</li>
            <li><code>moteur.h</code> : Fonctions de bas niveau pour contr√¥ler le moteur.</li>
            <li><code>temperature.h</code> : Fonction pour lire la temp√©rature.</li>
          </ul>
        </li>
        <li><strong>√Ä la racine du projet :</strong> Les fichiers de code principal.
          <ul>
            <li><code>master.cpp</code> : Le programme principal pour l'ESP32 agissant en <strong>ma√Ætre Modbus</strong> et h√©bergeant le <strong>serveur web</strong>.</li>
            <li><code>slave.cpp</code> : Le programme principal pour l'ESP32 agissant en <strong>esclave Modbus</strong>, g√©rant le moteur et la sonde de temp√©rature.</li>
          </ul>
        </li>
      </ul>

      <h3>4.2. Le C√¥t√© Esclave (<code>slave.cpp</code> et <code>modbus_slave.h</code>)</h3>
      <p>L'ESP32 esclave repr√©sente un √©quipement industriel distant. Il attend des commandes Modbus sur le bus s√©rie pour agir (piloter le moteur) ou fournir des donn√©es (temp√©rature).</p>

      <h4><code>slave.cpp</code> : Le C≈ìur de l'Esclave</h4>
      <p>Ce fichier g√®re la logique principale de l'esclave :</p>
      <ul>
        <li><strong>Initialisation (<code>setup</code>) :</strong> Configure le port s√©rie USB pour le d√©bogage (<code>Serial.begin(115200)</code>). Configure le <strong>port s√©rie UART 1</strong> de l'ESP32 (<code>modbus.begin(9600, SERIAL_8N1, 16, 17)</code>) pour la communication Modbus sur les GPIO 16 (RX) et 17 (TX). Initialise les broches du moteur (<code>moteur_init()</code>) et la r√©solution de l'ADC pour la temp√©rature (<code>analogReadResolution(12)</code>).</li>
        <li><strong>Boucle Principale (<code>loop</code>) : Traitement des Requ√™tes Modbus :</strong>
          <ul>
            <li>Attend un minimum de 8 octets sur le port Modbus (<code>modbus.available() < 8</code>).</li>
            <li>Lit la requ√™te entrante (<code>modbus.readBytes(req, 8)</code>).</li>
            <li>Effectue une <strong>validation cruciale</strong> : v√©rifie l'ID de l'esclave (<code>req[0] != SLAVE_ID</code>) et le <strong>CRC</strong> de la trame (<code>crcReq != calcCRC(req, 6)</code>). Une requ√™te invalide est ignor√©e.</li>
            <li>Extrait le code de fonction Modbus (<code>func = req[1]</code>) et l'adresse du registre (<code>reg = (req[2] << 8) | req[3]</code>).</li>
            <li><strong>Gestion de la Lecture de Temp√©rature (Fonction 0x03, Registre <code>REG_TEMP</code>) :</strong>
              <ul>
                <li>Appelle <code>lire_temperature()</code> pour obtenir la valeur.</li>
                <li>Met la temp√©rature √† l'√©chelle (<code>int(t * 10)</code>) et la convertit en un entier sur 16 bits.</li>
                <li>Construit manuellement la **trame de r√©ponse Modbus** incluant l'ID de l'esclave, le code de fonction, le nombre d'octets de donn√©es, les deux octets de la valeur, et le CRC calcul√©.</li>
                <li>Envoie la r√©ponse sur le bus Modbus (<code>modbus.write(rsp, 7)</code>).</li>
              </ul>
            </li>
            <li><strong>Gestion de la Commande Moteur (Fonction 0x06, Registre <code>REG_MOTOR</code>) :</strong>
              <ul>
                <li>Extrait la valeur de commande (<code>val</code>) de la requ√™te.</li>
                <li>Applique une logique simple : `0` pour arr√™ter (<code>moteur_stop()</code>), `1-500` pour avancer (<code>moteur_avance()</code>), `>500` pour reculer (<code>moteur_recule()</code>).</li>
                <li>Envoie un √©cho de la requ√™te comme r√©ponse standard pour la fonction 0x06 (<code>modbus.write(req, 8)</code>).</li>
              </ul>
            </li>
            <li>`sendException(modbus, func, 0x02);` : Si la requ√™te n'est pas reconnue ou est mal form√©e, une **r√©ponse d'exception Modbus** (ici, "Adresse de donn√©e ill√©gale") est envoy√©e au ma√Ætre.</li>
          </ul>
        </li>
      </ul>

      <h4><code>modbus_slave.h</code> : Outils Modbus pour l'Esclave</h4>
      <p>Ce fichier fournit les d√©finitions et fonctions g√©n√©riques :</p>
      <ul>
        <li><code>SLAVE_ID</code>, <code>REG_TEMP</code>, <code>REG_MOTOR</code> : Constantes d√©finissant l'ID de l'esclave (1) et les adresses des registres (0x0001 pour temp√©rature, 0x0002 pour moteur).</li>
        <li><code>calcCRC(const uint8_t* data, size_t len)</code> : Fonction essentielle pour le calcul du **CRC-16 Modbus**, utilis√©e pour valider l'int√©grit√© des trames.</li>
        <li><code>sendException(...)</code> : Fonction pour formater et envoyer une trame d'exception Modbus en cas d'erreur.</li>
      </ul>

      <h4><code>moteur.h</code> et <code>temperature.h</code> : Abstraction Mat√©rielle</h4>
      <p>Ces fichiers contiennent des fonctions simples pour abstraire les interactions mat√©rielles :</p>
      <ul>
        <li><code>moteur.h</code> : `moteur_init()`, `moteur_avance()`, `moteur_recule()`, `moteur_stop()` pour le contr√¥le du moteur.</li>
        <li><code>temperature.h</code> : `lire_temperature()` pour la lecture et conversion de la temp√©rature du thermistor.</li>
      </ul>

      <h3>4.3. Le C√¥t√© Ma√Ætre (<code>master.cpp</code> et <code>modbus_master.h</code>)</h3>
      <p>L'ESP32 ma√Ætre est le "cerveau" du syst√®me. Il agit comme un serveur web recevant des commandes d'un navigateur, puis traduit ces commandes en requ√™tes Modbus pour l'esclave.</p>

      <h4><code>master.cpp</code> : Le C≈ìur du Ma√Ætre et du Serveur Web</h4>
      <p>Ce fichier orchestre la connectivit√© Wi-Fi, le serveur web et l'interface avec le bus Modbus.</p>
      <ul>
        <li><strong>Initialisation (<code>setup</code>) :</strong> Initialise le d√©bogage s√©rie (<code>Serial.begin(115200)</code>). Connecte l'ESP32 au r√©seau Wi-Fi (<code>WiFi.begin(ssid, password)</code>) pour rendre le serveur web accessible. Configure le port s√©rie UART 1 pour Modbus (<code>modbus.begin(9600, SERIAL_8N1, 16, 17)</code>) avec les m√™mes param√®tres que l'esclave.
          <ul>
            <li><code>modbusMutex = xSemaphoreCreateMutex();</code> : **Crucial pour la gestion de la concurrence !** Un **mutex (s√©maphore binaire)** est cr√©√© pour garantir que seul un seul processus (une requ√™te web √† la fois) acc√®de au bus Modbus, √©vitant ainsi la corruption des donn√©es.</li>
            <li>Configure les routes HTTP du serveur web (ex: `/modbus/start` appelle `handleModbusStart()`). Le serveur est ensuite d√©marr√© (<code>server.begin()</code>).</li>
          </ul>
        </li>
        <li><strong>Boucle Principale (<code>loop</code>) : Gestion du Serveur Web :</strong> `server.handleClient();` est la ligne principale qui surveille les requ√™tes HTTP entrantes et appelle les fonctions de gestion appropri√©es.</li>
        <li><strong>Fonctions de Gestion des Requ√™tes Web (Handlers) :</strong>
          <ul>
            <li>Ces fonctions sont appel√©es par le serveur web lorsque des requ√™tes HTTP sp√©cifiques sont re√ßues. Elles utilisent le mutex pour g√©rer l'acc√®s au bus Modbus.</li>
            <li>`handleModbusStart()` :
              <ul>
                <li>Tente d'acqu√©rir le mutex (<code>xSemaphoreTake(modbusMutex, ...)</code>). Si le bus est occup√©, renvoie un code d'√©tat 503.</li>
                <li>Analyse le param√®tre `vitesse` de la requ√™te web.</li>
                <li>Appelle `modbusWriteRegister()` pour envoyer la commande Modbus √† l'esclave.</li>
                <li>Lib√®re le mutex (<code>xSemaphoreGive(modbusMutex)</code>).</li>
              </ul>
            </li>
            <li>`handleModbusStop()` : Similaire, mais envoie une commande d'arr√™t moteur.</li>
            <li>`handleTemp()` :
              <ul>
                <li>Acquiert le mutex.</li>
                <li>Appelle `modbusReadRegister()` pour lire la temp√©rature brute de l'esclave.</li>
                <li>Lib√®re le mutex.</li>
                <li>Convertit la valeur brute en temp√©rature r√©elle et renvoie une r√©ponse JSON au navigateur web.</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>

      <h4><code>modbus_master.h</code> : Outils Modbus pour le Ma√Ætre</h4>
      <p>Ce fichier fournit les fonctions cl√©s permettant au ma√Ætre d'interagir avec le bus Modbus :</p>
      <ul>
        <li><code>SLAVE_ID</code>, <code>REG_TEMP</code>, <code>REG_MOTOR</code> : M√™mes d√©finitions que c√¥t√© esclave pour la coh√©rence.</li>
        <li><code>calcCRC(...)</code> : La m√™me fonction de calcul du CRC-16 est pr√©sente.</li>
        <li><code>modbusWriteRegister(...)</code> : Construit et envoie une requ√™te Modbus "Write Single Register" (fonction 0x06). Attend la r√©ponse de l'esclave avec un **timeout** (500ms) et valide la r√©ponse re√ßue (CRC, ID, fonction, et les donn√©es d'√©cho).</li>
        <li><code>modbusReadRegister(...)</code> : Construit et envoie une requ√™te Modbus "Read Holding Registers" (fonction 0x03). Attend la r√©ponse avec timeout, valide la r√©ponse, et extrait la valeur lue.</li>
      </ul>



      <h2>5. Supervision : L'Interface Homme-Machine (IHM) Python</h2>
      <p>Cette partie du projet est essentielle car elle constitue l'<strong>Interface Homme-Machine (IHM)</strong>. C'est un script <strong>Python</strong> qui s'ex√©cute sur un ordinateur et qui dialogue avec le **serveur web embarqu√© sur l'ESP32 Ma√Ætre**. Son objectif est de fournir un moyen visuel et interactif pour surveiller la temp√©rature et contr√¥ler le moteur √† distance.</p>

      <h3>5.1. Fonctionnalit√©s Cl√©s du Script de Supervision</h3>
      <p>Le script Python est con√ßu pour √™tre un tableau de bord en temps r√©el :</p>
      <ul>
        <li><strong>Interaction avec l'ESP32 Ma√Ætre :</strong> La constante <code>ESP32_IP = "192.168.1.29"</code> d√©finit l'adresse IP de l'ESP32 Ma√Ætre, vers laquelle toutes les requ√™tes HTTP sont envoy√©es.</li>
        <li><strong>Lecture de la Temp√©rature (<code>get_temperature()</code> et <code>read_data()</code>) :</strong>
          <ul>
            <li><code>get_temperature()</code> interroge l'ESP32 Ma√Ætre via HTTP GET (<code>http://&lt;ESP32_IP&gt;/temp</code>). Elle inclut un **m√©canisme de re-tentative** et g√®re le code de statut **503 (Bus Modbus occup√©)** envoy√© par l'ESP32, en r√©essayant apr√®s un court d√©lai sans afficher d'erreur imm√©diate.</li>
            <li>La r√©ponse JSON est pars√©e pour extraire la temp√©rature, et `read_data()` met √† jour l'affichage dans l'IHM.</li>
          </ul>
        </li>
        <li><strong>Commandes Moteur (<code>start_motor()</code> et <code>stop_motor()</code>) :</strong>
          <ul>
            <li><code>start_motor()</code> r√©cup√®re la vitesse d'un curseur Tkinter, construit une URL avec ce param√®tre (<code>http://&lt;ESP32_IP&gt;/modbus/start?vitesse=&lt;valeur&gt;</code>), envoie la requ√™te HTTP, et met √† jour l'√©tat visuel du moteur (üü¢ MARCHE / ‚ö†Ô∏è Erreur) en fonction de la r√©ponse HTTP.</li>
            <li><code>stop_motor()</code> envoie une requ√™te HTTP √† <code>http://&lt;ESP32_IP&gt;/modbus/stop</code> pour arr√™ter le moteur.</li>
          </ul>
        </li>
        <li><strong>Mise √† Jour Automatique (<code>auto_update()</code>) :</strong> La ligne `root.after(2000, auto_update)` programme un rafra√Æchissement p√©riodique des mesures toutes les 2 secondes, offrant une supervision "en direct".</li>
      </ul>

      <h3>5.2. Interface Graphique Utilisateur (GUI) avec Tkinter</h3>
      <p>Le script utilise la biblioth√®que <strong>Tkinter</strong> pour construire l'interface visuelle :</p>
      <ul>
        <li><strong>Fen√™tre Principale (<code>root = tk.Tk()</code>) :</strong> Cr√©e la fen√™tre de l'application.</li>
        <li><strong>√âl√©ments d'Affichage :</strong> Des <code>tk.Label</code> pour le titre, la temp√©rature et l'√©tat du moteur. Un <code>tk.Scale</code> (curseur) permet de s√©lectionner la vitesse du moteur.</li>
        <li><strong>Boutons de Commande :</strong> Des <code>tk.Button</code> pour "Lancer le moteur", "Arr√™ter le moteur" et "Rafra√Æchir mesures", chacun li√© √† sa fonction Python.</li>
        <li><strong>Stylisation :</strong> Utilisation de param√®tres comme `bg` (couleur de fond), `fg` (couleur du texte) et `font` pour l'esth√©tique.</li>
        <li><strong>Boucle Principale de l'IHM (<code>root.mainloop()</code>) :</strong> Lance la boucle d'√©v√©nements Tkinter, g√©rant les interactions utilisateur et les mises √† jour de l'interface.</li>
      </ul>

      <h3>5.3. Flux de Donn√©es et Contr√¥le</h3>
      <p>Le script de supervision Python compl√®te la cha√Æne de communication :</p>
      <ol>
        <li>L'utilisateur interagit avec l'IHM Python.</li>
        <li>Le script Python envoie des requ√™tes <strong>HTTP</strong> √† l'<strong>ESP32 Ma√Ætre</strong>.</li>
        <li>L'ESP32 Ma√Ætre (serveur web) interpr√®te ces requ√™tes.</li>
        <li>L'ESP32 Ma√Ætre traduit les commandes HTTP en requ√™tes <strong>Modbus RTU</strong> et les envoie via UART-TTL √† l'<strong>ESP32 Esclave</strong>.</li>
        <li>L'ESP32 Esclave lit la temp√©rature ou pilote le moteur.</li>
        <li>L'ESP32 Esclave envoie des r√©ponses Modbus RTU √† l'ESP32 Ma√Ætre.</li>
        <li>L'ESP32 Ma√Ætre (client web) formate ces r√©ponses Modbus et les renvoie en tant que r√©ponses <strong>HTTP</strong> au script Python.</li>
        <li>Le script Python met √† jour l'IHM pour refl√©ter l'√©tat du syst√®me.</li>
      </ol>

 <br>
     <img src="image/supervision.png" alt="Sch√©ma de c√¢blage Modbus" style="max-width: 85%; height: auto; display: block;">
         <p><em>Supervision (Moteur en marche/Arrette)</em>

 


      <h2>6. Sniffing des Trames et Analyse R√©seau</h2>

      <h3>6.1. Sniffing des Trames UART avec un Analyseur Logique</h3>
      <p>Pour une compr√©hension approfondie du protocole Modbus RTU sur UART-TTL, l'utilisation d'un <strong>analyseur logique</strong> est un outil de d√©bogage et d'analyse indispensable.</p>
      <ul>
        <li><strong>Branchement :</strong> Connectez l'analyseur logique aux broches <strong>TX et RX</strong> de chaque ESP32 (et au GND commun). √áa vous permet de capturer les signaux √©lectriques √©chang√©s sur le bus s√©rie en temps r√©el.</li>
        <li><strong>D√©codage UART et Visualisation :</strong> Configurez le d√©codeur UART de votre analyseur logique avec les bons param√®tres : **9600 bauds, 8N1** (8 bits de donn√©es, pas de parit√©, 1 bit de stop). L'analyseur affichera chaque octet captur√© en **hexad√©cimal**, ce qui vous permettra de visualiser directement la s√©quence des octets de la trame Modbus. C'est parfait pour v√©rifier la conformit√© des trames envoy√©es et re√ßues par vos ESP32.</li>
        <li><strong>Synchronisation des Trames :</strong> Le d√©codeur UART de l'analyseur logique utilise le **silence inter-trame (‚â• 3,5T)** pour d√©limiter automatiquement les trames Modbus compl√®tes. √áa facilite grandement leur lecture et leur analyse, en vous aidant √† distinguer clairement les requ√™tes des r√©ponses.</li>
        <li><strong>Identification Manuelle des Octets Modbus :</strong> Avec la visualisation hexad√©cimale, vous pouvez v√©rifier manuellement que l'adresse de l'esclave, le code de fonction, les donn√©es et le CRC correspondent aux sp√©cifications du protocole Modbus RTU. C'est crucial pour valider le bon fonctionnement de votre impl√©mentation et diagnostiquer d'√©ventuels probl√®mes de communication.</li>
      </ul>

      <h3>6.2. Sniffing du Trafic HTTP Wi-Fi avec Wireshark (Supervision)</h3>
      <p>√âtant donn√© que la supervision de notre syst√®me passe par une communication **HTTP non chiffr√©e** sur le r√©seau Wi-Fi, il est possible d'observer et d'analyser ce trafic √† l'aide d'un outil comme **Wireshark**.</p>
      <ul>
        <li><strong>Capture de Paquets :</strong> Utilisez Wireshark sur un PC connect√© au m√™me r√©seau Wi-Fi que l'ESP32 ma√Ætre. Lancez une capture sur votre interface Wi-Fi. Vous pourrez alors voir tous les paquets transitant entre votre PC (ex√©cutant l'IHM Python) et l'ESP32 ma√Ætre.</li>
        <li><strong>Analyse des Requ√™tes et R√©ponses HTTP :</strong> Dans Wireshark, filtrez le trafic pour n'afficher que les paquets HTTP (par exemple, en tapant `http` dans la barre de filtre). Vous pourrez inspecter le contenu des requ√™tes GET (pour lire la temp√©rature, par exemple) et les r√©ponses JSON envoy√©es par l'ESP32.</li>
        <li><strong>Identification des Donn√©es en Clair :</strong> Cette analyse d√©montrera que les commandes (comme la vitesse du moteur) et les donn√©es (la temp√©rature) sont transmises en clair sur le r√©seau. C'est une vuln√©rabilit√© majeure en cybers√©curit√©, soulignant l'importance du chiffrement (HTTPS) pour prot√©ger les informations sensibles.</li>
      </ul>
<a href="image/get_temp_request.png" target="_blank">
    <img src="image/get_temp_request.png" alt="Requ√™te HTTP GET temp√©rature" style="max-width: 100%;">
</a>
<p><em>Capture wireshark requ√™te GET temp√©rature</em></p>
<br>


<a href="image/get_temp_response.png" target="_blank">
    <img src="image/get_temp_response.png" alt="R√©ponse HTTP GET temp√©rature" style="max-width: 100%;">
</a>
<p><em>Capture wireshark r√©ponse GET temp√©rature</em></p>
<br>
  <h2>7. Extraction et Analyse du Firmware ESP32</h2>

  <h3>7.1. Dump du firmware via esptool.py</h3>
  <p>Pour lire la m√©moire flash de l‚ÄôESP32 et en extraire le firmware, utilisez <code>esptool.py</code> :</p>
  <pre class="linenums"><code>
# Installer esptool si besoin
pip install esptool

# Lire 4 Mo de flash (ajustez la taille selon votre ESP32)
esptool.py --port /dev/ttyUSB0 read_flash 0x00000 0x400000 firmware.bin
  </code></pre>
<a href="image/extraction_ok.png" target="_blank">
    <img src="image/extraction_ok.png" alt="hxd" style="max-width: 100%;">
</a>
<p><em>Extraction</em></p>
<br>
  <h3>7.2. Ouverture du binaire avec HxD</h3>
  <p>Ouvrez <code>firmware.bin</code> dans l‚Äô√©diteur hexad√©cimal HxD (Windows) :</p>
  <ul>
    <li>Fichier ‚Üí Ouvrir ‚Üí s√©lectionnez <code>firmware.bin</code>.</li>
    <li>Activez ¬´ Affichage texte ¬ª pour voir √† droite la colonne ASCII.</li>
  </ul>

<a href="image/data.png" target="_blank">
    <img src="image/data.png" alt="hxd" style="max-width: 100%;">
</a>
<p><em>Binaire</em></p>
<br>
 

      <h2>8. Perspectives d'√âvolution</h2>
      <p>Ce projet de base ouvre la voie √† de nombreuses am√©liorations pour le rendre plus robuste et adapt√© √† un environnement industriel r√©el.</p>

      <h3>8.1. Migration vers RS-485 (bus diff√©rentiel)</h3>
      <ul>
        <li>Ajout de modules **MAX485** ou √©quivalents sur chaque ESP32 pour convertir les signaux TTL en RS-485. Cela implique la gestion de la broche DE/RE (Data Enable/Receive Enable) pour contr√¥ler la direction de la transmission.</li>
        <li>La migration vers le **RS-485** permettra une communication fiable sur de **plus longues distances** et la mise en place d'une **topologie multi-drop** (plusieurs esclaves sur le m√™me bus).</li>
      </ul>

      <h3>8.2. Support multi-registres et multi-fonctions</h3>
      <ul>
        <li>Actuellement, le projet ne g√®re que la lecture d'un seul registre (temp√©rature, fonction 0x03) et l'√©criture d'un seul registre (moteur, fonction 0x06). L'impl√©mentation de fonctions Modbus suppl√©mentaires, comme l'**√©criture de registres multiples (0x10)** ou la **lecture d'entr√©es discr√®tes (0x02)**, rendrait le syst√®me plus polyvalent.</li>
      </ul>

      <h3>8.3. Gestion d‚Äôerreurs et timeout</h3>
      <ul>
        <li>Am√©liorer la robustesse du ma√Ætre en impl√©mentant des m√©canismes de **retransmissions** en cas de non-r√©ponse de l'esclave ou de r√©ponse invalide.</li>
        <li>Mettre en place un **journal d'erreurs** d√©taill√© pour faciliter le d√©bogage et la maintenance.</li>
      </ul>

      <h3>8.4. Int√©gration r√©seau (MQTT, OPC UA)</h3>
      <ul>
        <li>Pour une int√©gration plus pouss√©e dans des syst√®mes d'information industriels (IIoT), l'ESP32 ma√Ætre pourrait √™tre √©tendu pour :
          <ul>
            <li>Publier les mesures (temp√©rature, √©tat moteur) via le protocole **MQTT** vers un courtier.</li>
            <li>Agir comme un client **OPC UA** pour s'int√©grer √† des syst√®mes SCADA industriels.</li>
          </ul>
        </li>
      </ul>


      <h2>9. S√©curit√© &amp; Hacking Modbus</h2>
      <p>La simplicit√© de Modbus, bien que b√©n√©fique, le rend √©galement vuln√©rable si des mesures de s√©curit√© ne sont pas prises, surtout lorsqu'il est connect√© √† un r√©seau IP.</p>

      <h3>9.1. Menaces Modbus : injection, spoofing</h3>
      <ul>
        <li><strong>Injection de trames malveillantes :</strong> Un attaquant ayant acc√®s au bus Modbus (physiquement ou via un r√©seau non s√©curis√©) pourrait injecter de fausses commandes pour falsifier les donn√©es ou piloter les √©quipements de mani√®re non autoris√©e.</li>
        <li><strong>Spoofing :</strong> Un attaquant pourrait se faire passer pour un ma√Ætre ou un esclave l√©gitime pour intercepter ou manipuler la communication.</li>
      </ul>

      <h3>9.2. Attaques par d√©ni de service</h3>
      <ul>
        <li>L'**inondation du bus** avec un grand nombre de requ√™tes ou de donn√©es inutiles peut saturer la liaison et bloquer la communication l√©gitime, entra√Ænant un d√©ni de service du syst√®me de contr√¥le.</li>
      </ul>

      <h3>9.3. Analyse passive des trames UART</h3>
      <ul>
        <li>Le **sniffing** avec un **analyseur logique** sur les broches TX/RX permet √† un attaquant d'observer passivement le flux de donn√©es Modbus, de comprendre la logique de communication et d'identifier les registres critiques sans alt√©rer le fonctionnement. Cette technique est souvent utilis√©e pour la reconnaissance avant une attaque.</li>
      </ul>

      <h3>9.4. Sniffing r√©seau Wi-Fi HTTP (supervision)</h3>
      <ul>
        <li>√âtant donn√© que la supervision utilise une communication Wi-Fi **HTTP non chiffr√©e**, un outil comme **Wireshark** peut facilement **capturer les paquets HTTP** entre le PC et l'ESP32 ma√Ætre. Cela exposerait les commandes (ex: vitesse moteur) et les donn√©es (temp√©rature) en clair, posant un risque de confidentialit√© et d'int√©grit√© si l'acc√®s au r√©seau Wi-Fi n'est pas s√©curis√©. L'analyse des ent√™tes et du contenu des requ√™tes HTTP est cruciale pour identifier d'√©ventuelles vuln√©rabilit√©s.</li>
      </ul>
 




      <h2>10. Conclusion G√©n√©rale</h2>

      <h3>10.1. Bilan du projet</h3>
      <p>Ce projet a permis le d√©ploiement complet d'un syst√®me Modbus RTU bas-niveau entre deux ESP32, incluant une analyse approfondie de la couche physique et liaison. Il a √©galement mis en lumi√®re l'int√©gration d'une interface de supervision web, compl√©tant ainsi une cha√Æne de commande et de mesure de bout en bout.</p>

      <h3>10.2. Limites de la version UART directe</h3>
      <p>La version actuelle, utilisant l'UART-TTL direct, pr√©sente des limites notables : une **port√©e limit√©e** (‚â§ 5 m√®tres), une restriction √† deux n≈ìuds seulement, et une sensibilit√© inh√©rente au bruit et aux interf√©rences.</p>

      <h3>10.3. Int√©gration possible de tout type d‚ÄôE/S</h3>
      <p>Le c≈ìur du protocole Modbus est sa polyvalence. Le syst√®me d√©velopp√© peut √™tre √©tendu pour int√©grer tout type d'entr√©es/sorties (E/S) industrielles : capteurs de pression, de niveau, de d√©bit, relais, variateurs de vitesse, LEDs, et tout autre module lisible ou commandable via Modbus.</p>

      <h3>10.4. Ouvertures industrielles : robustesse, cybers√©curit√©</h3>
      <p>Pour une application industrielle r√©elle, des √©volutions sont indispensables :</p>
      <ul>
        <li>La migration vers le **RS-485** est cruciale pour la robustesse et la capacit√© √† g√©rer un bus multi-drop avec de nombreux esclaves.</li>
        <li>Le renforcement de la **cybers√©curit√©** (chiffrement des communications, authentification des appareils) est imp√©ratif pour prot√©ger le syst√®me contre les menaces.</li>
      </ul>
 </article>

    </main>
<div id="footer-placeholder"></div>

    <script>
document.addEventListener("DOMContentLoaded", function() {
  // Charger nav
  fetch("nav.html")
    .then(resp => resp.text())
    .then(html => {
      document.getElementById("nav-placeholder").innerHTML = html;
    })
    .catch(err => console.error("Erreur chargement nav :", err));

  // Charger footer
  fetch("footer.html")
    .then(resp => resp.text())
    .then(html => {
      document.getElementById("footer-placeholder").innerHTML = html;
    })
    .catch(err => console.error("Erreur chargement footer :", err));
});

  
</script>

</body>